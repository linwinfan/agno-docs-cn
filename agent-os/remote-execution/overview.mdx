---
title: "远程执行"
sidebarTitle: "概述"
description: "执行托管在远程 AgentOS 实例上的智能体、团队和工作流"
---

远程执行使您能够运行托管在远程 AgentOS 实例上的智能体、团队和工作流。这适用于：

- **分布式架构**: 在不同服务器上运行专门的智能体
- **微服务**: 将您的智能体系统分解为独立服务
- **网关模式**: 为多个 AgentOS 实例创建统一 API

## 核心组件

<CardGroup cols={2}>
  <Card title="AgentOSClient" icon="plug" href="/reference/agent-os/client">
    用于直接访问任何 AgentOS 端点的低级客户端
  </Card>
  <Card title="RemoteAgent" icon="robot" href="/agent-os/remote-execution/remote-agent">
    在远程 AgentOS 实例上执行智能体
  </Card>
  <Card title="RemoteTeam" icon="users" href="/agent-os/remote-execution/remote-team">
    在远程 AgentOS 实例上执行团队
  </Card>
  <Card title="RemoteWorkflow" icon="diagram-project" href="/agent-os/remote-execution/remote-workflow">
    在远程 AgentOS 实例上执行工作流
  </Card>
</CardGroup>

## 快速开始

### 1. 设置远程 AgentOS 服务器

首先，创建并运行一个将托管您的智能体的 AgentOS 实例：

```python
# server.py
from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.os import AgentOS

agent = Agent(
    name="助手",
    id="assistant-agent",
    model=OpenAIChat(id="gpt-5-mini"),
    instructions="你是一个有用的助手。",
)

agent_os = AgentOS(
    id="remote-server",
    agents=[agent],
    debug_mode=True,
)

if __name__ == "__main__":
    agent_os.serve(
        app="server:app",
        reload=True,
        port=8000,
        host="0.0.0.0"
    )
```

### 2. 连接到远程 AgentOS

使用 `AgentOSClient` 连接到远程实例：

```python
# client.py
from agno.agent import Agent
from agno.os.client import AgentOSClient

# 创建客户端连接
client = AgentOSClient(
    url="http://localhost:8000",
    headers={"Authorization": "Bearer your-token"}
)

# 获取远程智能体
remote_agent = client.agent("assistant-agent")

# 执行远程智能体
response = remote_agent.run("你好，请介绍一下你自己")
print(response.content)
```

## 架构概述

### 分布式智能体系统

```mermaid
graph TB
    subgraph "客户端应用"
        A[用户界面] --> B[AgentOS 客户端]
        B --> C[RemoteAgent]
        B --> D[RemoteTeam]
        B --> E[RemoteWorkflow]
    end
    
    subgraph "网络层"
        F[HTTP/WebSocket] 
        G[认证中间件]
        H[负载均衡器]
    end
    
    subgraph "AgentOS 集群"
        I[AgentOS 实例 1]
        J[AgentOS 实例 2]
        K[AgentOS 实例 N]
        
        I --> I1[专门智能体 A]
        I --> I2[专门智能体 B]
        J --> J1[团队协作]
        J --> J2[工作流引擎]
        K --> K1[计算密集型任务]
        K --> K2[数据访问层]
    end
    
    B --> F
    F --> G
    G --> H
    H --> I
    H --> J
    H --> K
```

### 通信模式

<Tabs>
  <Tab title="同步执行">
    适用于需要立即响应的场景：
    
    ```python
    # 同步执行 - 等待结果
    response = remote_agent.run("处理这个任务")
    print(f"结果: {response.content}")
    ```
    
    **优点**:
    - 简单直接
    - 立即获得结果
    - 易于调试
    
    **缺点**:
    - 阻塞客户端
    - 不适合长时间运行的任务
  </Tab>
  
  <Tab title="异步执行">
    适用于后台任务和长时间运行的操作：
    
    ```python
    # 异步执行 - 不等待结果
    task_id = remote_agent.run_async("处理复杂任务")
    
    # 稍后检查结果
    result = remote_agent.get_result(task_id)
    ```
    
    **优点**:
    - 非阻塞
    - 适合长时间运行的任务
    - 可以并行处理多个任务
    
    **缺点**:
    - 需要额外的状态管理
    - 结果获取稍微复杂
  </Tab>
  
  <Tab title="流式执行">
    适用于实时响应和增量输出：
    
    ```python
    # 流式执行 - 实时获取输出
    for chunk in remote_agent.run_stream("生成一个故事"):
        print(chunk, end="", flush=True)
    ```
    
    **优点**:
    - 实时反馈
    - 更好的用户体验
    - 适合生成式任务
    
    **缺点**:
    - 需要处理流式数据
    - 网络连接要求更高
  </Tab>
</Tabs>

## 高级配置

### 1. 连接池管理

```python
from agno.os.client import AgentOSClient
from agno.os.client.pool import ConnectionPool

# 创建连接池
pool = ConnectionPool(
    base_url="http://localhost:8000",
    max_connections=10,
    timeout=30,
    retry_attempts=3
)

# 使用连接池创建客户端
client = AgentOSClient(
    connection_pool=pool,
    headers={"Authorization": "Bearer your-token"}
)
```

### 2. 负载均衡

```python
from agno.os.client import LoadBalancedClient
from agno.os.client.strategies import RoundRobinStrategy

# 配置多个 AgentOS 实例
servers = [
    "http://agentos-1:8000",
    "http://agentos-2:8000", 
    "http://agentos-3:8000"
]

# 创建负载均衡客户端
client = LoadBalancedClient(
    servers=servers,
    strategy=RoundRobinStrategy(),
    health_check_interval=60
)
```

### 3. 故障转移

```python
from agno.os.client import FailoverClient

# 主备配置
primary_server = "http://primary-agentos:8000"
backup_servers = [
    "http://backup-1:8000",
    "http://backup-2:8000"
]

# 创建故障转移客户端
client = FailoverClient(
    primary=primary_server,
    backups=backup_servers,
    failover_timeout=5,
    auto_recovery=True
)
```

## 安全考虑

### 1. 认证和授权

```python
# 服务端 - 配置 JWT 中间件
from agno.os.middleware import JWTMiddleware

agent_os = AgentOS(
    agents=[agent],
    middleware=[
        JWTMiddleware(
            secret_key="your-secret-key",
            algorithm="HS256",
            exclude_paths=["/health", "/metrics"]
        )
    ]
)

# 客户端 - 使用认证
client = AgentOSClient(
    url="http://localhost:8000",
    headers={
        "Authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
    }
)
```

### 2. 加密通信

```python
# 使用 HTTPS
client = AgentOSClient(
    url="https://secure-agentos.example.com",
    verify_ssl=True,  # 验证 SSL 证书
    ssl_cert_path="/path/to/ca.crt"  # 自定义 CA 证书
)

# 或使用自定义 SSL 上下文
import ssl
ssl_context = ssl.create_default_context()
ssl_context.load_verify_locations("/path/to/ca.crt")

client = AgentOSClient(
    url="https://secure-agentos.example.com",
    ssl_context=ssl_context
)
```

### 3. 访问控制

```python
# 基于角色的访问控制
client = AgentOSClient(
    url="http://localhost:8000",
    headers={
        "Authorization": "Bearer your-token",
        "X-User-Role": "admin",  # 用户角色
        "X-User-Permissions": "read,write,execute"  # 权限列表
    }
)

# 限制访问特定智能体
try:
    # 只有管理员才能访问
    admin_agent = client.agent("admin-only-agent")
    response = admin_agent.run("执行管理任务")
except PermissionError as e:
    print(f"访问被拒绝: {e}")
```

## 监控和日志

### 1. 性能监控

```python
import time
from agno.os.client import AgentOSClient

class MonitoredClient(AgentOSClient):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.metrics = {
            "request_count": 0,
            "total_response_time": 0,
            "error_count": 0
        }
    
    def run(self, *args, **kwargs):
        start_time = time.time()
        self.metrics["request_count"] += 1
        
        try:
            response = super().run(*args, **kwargs)
            
            response_time = time.time() - start_time
            self.metrics["total_response_time"] += response_time
            
            return response
        except Exception as e:
            self.metrics["error_count"] += 1
            raise
    
    def get_metrics(self):
        if self.metrics["request_count"] > 0:
            avg_response_time = (
                self.metrics["total_response_time"] / 
                self.metrics["request_count"]
            )
            error_rate = (
                self.metrics["error_count"] / 
                self.metrics["request_count"]
            )
            
            return {
                "total_requests": self.metrics["request_count"],
                "avg_response_time": avg_response_time,
                "error_rate": error_rate
            }
        
        return {}

# 使用监控客户端
client = MonitoredClient(url="http://localhost:8000")
response = client.run("测试消息")
print(client.get_metrics())
```

### 2. 日志记录

```python
import logging
from agno.os.client import AgentOSClient

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class LoggingClient(AgentOSClient):
    def run(self, *args, **kwargs):
        logger.info(f"执行远程智能体: {args}")
        
        try:
            response = super().run(*args, **kwargs)
            logger.info(f"执行成功，响应长度: {len(response.content)}")
            return response
        except Exception as e:
            logger.error(f"执行失败: {e}")
            raise

# 使用日志客户端
client = LoggingClient(url="http://localhost:8000")
response = client.run("测试消息")
```

## 最佳实践

### 1. 连接管理

- **连接复用**: 使用连接池减少连接开销
- **超时设置**: 设置合理的超时时间避免长时间等待
- **重试机制**: 实现指数退避重试策略
- **连接健康检查**: 定期检查连接状态

### 2. 错误处理

- **优雅降级**: 在远程服务不可用时提供本地备用方案
- **错误分类**: 区分网络错误、认证错误和业务错误
- **详细日志**: 记录错误详情用于调试
- **用户友好**: 提供清晰的错误消息

### 3. 性能优化

- **批量操作**: 尽可能批量处理请求
- **缓存策略**: 缓存频繁访问的结果
- **异步处理**: 使用异步操作提高并发性能
- **负载均衡**: 在多个实例间分配负载

### 4. 安全考虑

- **最小权限**: 只授予必要的权限
- **定期轮换**: 定期更换认证令牌
- **网络隔离**: 使用 VPN 或专用网络
- **审计日志**: 记录所有访问和操作

## 故障排除

### 常见问题

#### 连接超时

**问题**: 客户端连接远程 AgentOS 超时
**解决方案**:
1. 检查网络连接
2. 增加超时时间设置
3. 验证防火墙配置
4. 检查服务端状态

#### 认证失败

**问题**: 认证令牌无效或过期
**解决方案**:
1. 验证令牌格式和内容
2. 检查令牌过期时间
3. 确认密钥配置
4. 重新生成有效令牌

#### 性能问题

**问题**: 远程执行响应缓慢
**解决方案**:
1. 检查网络延迟
2. 优化服务端性能
3. 使用连接池
4. 实施缓存策略

## 下一步

- 查看[RemoteAgent](/agent-os/remote-execution/remote-agent)
- 了解[RemoteTeam](/agent-os/remote-execution/remote-team)
- 探索[RemoteWorkflow](/agent-os/remote-execution/remote-workflow)
- 查看[AgentOSClient](/reference/agent-os/client)