---
title: "API 使用"
sidebarTitle: "API 使用"
description: "使用 AgentOS API 运行您的智能体/团队/工作流"
keywords: [agentos api, 智能体 api, 团队 api, 工作流 api]
---

AgentOS API 提供以下端点：
- **运行智能体**: `POST /agents/{agent_id}/runs`  （参见 [API 参考](/reference-api/schema/agents/create-agent-run)）
- **运行团队**: `POST /teams/{team_id}/runs`  （参见 [API 参考](/reference-api/schema/teams/create-team-run)）
- **运行工作流**: `POST /workflows/{workflow_id}/runs`  （参见 [API 参考](/reference-api/schema/workflows/execute-workflow)）

这些端点支持基于表单的输入。以下是使用 API 运行智能体的示例：

```bash
curl --location 'http://localhost:7777/agents/agno-agent/runs' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'message=告诉我关于 Agno 的信息。' \
    --data-urlencode 'stream=True' \
    --data-urlencode 'user_id=john@example.com' \
    --data-urlencode 'session_id=session_123'
```

## 向智能体/团队/工作流传递参数

智能体、团队和工作流的 `run()` 和 `arun()` 端点支持各种运行时参数。有关详细信息，请参见[智能体运行模式](/reference/agents/agent#run)、[团队运行模式](/reference/teams/team#run)、[工作流运行模式](/reference/workflows/workflow#run)。

通过 API 向智能体、团队或工作流传递 `session_state`、`dependencies`、`metadata` 等参数是一种常见的模式。

要通过 AgentOS API 传递这些参数，您可以简单地将它们指定为基于表单的参数。

以下是将 `dependencies` 传递给智能体的示例：

```python dependencies_to_agent.py
from agno.agent import Agent
from agno.db.postgres import PostgresDb
from agno.os import AgentOS

# 设置数据库
db = PostgresDb(id="basic-db", db_url="postgresql+psycopg://ai:ai@localhost:5532/ai")

# 设置基本智能体、团队和工作流
story_writer = Agent(
    id="story-writer-agent",
    name="故事作家智能体",
    db=db,
    markdown=True,
    instructions="您是一个故事作家。您被要求写一个关于机器人的故事。始终将机器人命名为 {robot_name}",
)

# 创建 AgentOS
agent_os = AgentOS(agents=[story_writer])

if __name__ == "__main__":
    agent_os.launch()
```

现在，您可以通过 API 向此智能体传递 `dependencies`：

```bash
curl --location 'http://localhost:7777/agents/story-writer-agent/runs' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'message=写一个关于机器人的短故事' \
    --data-urlencode 'dependencies[robot_name]=瓦力' \
    --data-urlencode 'user_id=user@example.com'
```

## 支持的参数

### 基本参数

| 参数 | 类型 | 描述 |
|-------|------|------|
| `message` | string | 要发送给智能体的消息 |
| `user_id` | string | 用户标识符 |
| `session_id` | string | 会话标识符 |
| `stream` | boolean | 是否流式响应 |

### 高级参数

| 参数 | 类型 | 描述 |
|-------|------|------|
| `session_state` | object | 会话状态数据 |
| `dependencies` | object | 依赖项数据 |
| `metadata` | object | 元数据 |
| `monitor` | boolean | 是否启用监控 |
| `debug` | boolean | 是否启用调试模式 |

## 流式响应

AgentOS API 支持流式响应，允许您实时接收智能体的输出：

```bash
curl --location 'http://localhost:7777/agents/assistant/runs' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'message=解释量子计算' \
    --data-urlencode 'stream=True' \
    --data-urlencode 'user_id=user@example.com'
```

### Python 流式客户端

```python
import requests
import json

def stream_agent_response(agent_id: str, message: str, user_id: str):
    url = f"http://localhost:7777/agents/{agent_id}/runs"
    
    data = {
        "message": message,
        "stream": "True",
        "user_id": user_id
    }
    
    response = requests.post(url, data=data, stream=True)
    
    for line in response.iter_lines():
        if line:
            try:
                # 解析 SSE 格式
                if line.startswith(b"data: "):
                    data = line[6:]  # 移除 "data: " 前缀
                    event = json.loads(data.decode("utf-8"))
                    print(event.get("content", ""), end="")
            except json.JSONDecodeError:
                continue

# 使用示例
stream_agent_response(
    agent_id="assistant",
    message="解释机器学习的基本概念",
    user_id="user@example.com"
)
```

### JavaScript 流式客户端

```javascript
async function streamAgentResponse(agentId, message, userId) {
    const url = `http://localhost:7777/agents/${agentId}/runs`;
    
    const formData = new FormData();
    formData.append('message', message);
    formData.append('stream', 'true');
    formData.append('user_id', userId);
    
    const response = await fetch(url, {
        method: 'POST',
        body: formData
    });
    
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
            if (line.startsWith('data: ')) {
                try {
                    const data = JSON.parse(line.slice(6));
                    process.stdout.write(data.content || '');
                } catch (e) {
                    // 忽略解析错误
                }
            }
        }
    }
}

// 使用示例
streamAgentResponse(
    'assistant',
    '解释人工智能的历史',
    'user@example.com'
);
```

## 会话管理

### 创建会话

```bash
curl --location 'http://localhost:7777/sessions' \
    --header 'Content-Type: application/json' \
    --data '{
        "user_id": "user@example.com",
        "agent_id": "assistant",
        "session_name": "客户支持对话"
    }'
```

### 获取会话历史

```bash
curl --location 'http://localhost:7777/sessions/session_123/messages' \
    --header 'Authorization: Bearer your-jwt-token'
```

### 更新会话状态

```bash
curl --location --request PUT 'http://localhost:7777/sessions/session_123' \
    --header 'Content-Type: application/json' \
    --data '{
        "session_state": {
            "user_preference": "中文",
            "context": "技术支持"
        }
    }'
```

## 团队 API

### 运行团队

```bash
curl --location 'http://localhost:7777/teams/support-team/runs' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'message=我需要技术帮助' \
    --data-urlencode 'user_id=customer@example.com' \
    --data-urlencode 'session_id=session_456'
```

### 团队配置

```python
from agno.team import Team
from agno.agent import Agent

# 创建支持团队
support_team = Team(
    id="support-team",
    name="技术支持团队",
    agents=[
        Agent(name="一级支持", instructions="处理基本技术问题"),
        Agent(name="二级支持", instructions="处理复杂技术问题"),
        Agent(name="专家支持", instructions="处理高级技术问题")
    ],
    instructions="协作解决用户技术问题"
)

# 添加到 AgentOS
agent_os = AgentOS(teams=[support_team])
```

## 工作流 API

### 运行工作流

```bash
curl --location 'http://localhost:7777/workflows/customer-onboarding/runs' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --data-urlencode 'message=开始客户入职流程' \
    --data-urlencode 'user_id=new-customer@example.com' \
    --data-urlencode 'workflow_data={"customer_name":"张三","plan":"premium"}'
```

### 工作流定义

```python
from agno.workflow import Workflow
from agno.agent import Agent

# 创建入职工作流
onboarding_workflow = Workflow(
    id="customer-onboarding",
    name="客户入职工作流",
    agents=[
        Agent(name="欢迎助手", instructions="发送欢迎消息"),
        Agent(name="账户设置", instructions="设置客户账户"),
        Agent(name="培训协调员", instructions="安排培训会议")
    ],
    steps=[
        {"agent": "欢迎助手", "action": "send_welcome"},
        {"agent": "账户设置", "action": "setup_account"},
        {"agent": "培训协调员", "action": "schedule_training"}
    ]
)

# 添加到 AgentOS
agent_os = AgentOS(workflows=[onboarding_workflow])
```

## 错误处理

### 常见错误响应

```json
{
    "error": "智能体未找到",
    "code": "AGENT_NOT_FOUND",
    "details": {
        "agent_id": "unknown-agent",
        "available_agents": ["assistant", "story-writer"]
    }
}
```

### 错误代码

| 错误代码 | HTTP 状态码 | 描述 |
|-------|-------------|------|
| `AGENT_NOT_FOUND` | 404 | 指定的智能体不存在 |
| `TEAM_NOT_FOUND` | 404 | 指定的团队不存在 |
| `WORKFLOW_NOT_FOUND` | 404 | 指定的工作流不存在 |
| `INVALID_INPUT` | 400 | 输入数据无效 |
| `PERMISSION_DENIED` | 403 | 权限不足 |
| `RATE_LIMIT_EXCEEDED` | 429 | 请求频率超限 |

### 错误处理示例

```python
import requests

def run_agent_with_error_handling(agent_id: str, message: str):
    url = f"http://localhost:7777/agents/{agent_id}/runs"
    
    try:
        response = requests.post(url, data={"message": message})
        response.raise_for_status()
        
        return response.json()
    
    except requests.exceptions.HTTPError as e:
        if response.status_code == 404:
            print(f"智能体 '{agent_id}' 未找到")
        elif response.status_code == 403:
            print("权限不足，请检查认证")
        elif response.status_code == 429:
            print("请求过于频繁，请稍后重试")
        else:
            print(f"HTTP 错误: {e}")
    
    except requests.exceptions.RequestException as e:
        print(f"网络错误: {e}")
    
    return None

# 使用示例
result = run_agent_with_error_handling(
    agent_id="assistant",
    message="你好"
)
```

## 性能优化

### 批量请求

```python
import asyncio
import aiohttp

async def batch_run_agents(agent_requests):
    """批量运行智能体"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        
        for request in agent_requests:
            task = run_single_agent(session, request)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results

async def run_single_agent(session, request):
    url = f"http://localhost:7777/agents/{request['agent_id']}/runs"
    
    async with session.post(url, data=request['data']) as response:
        return await response.json()

# 使用示例
requests = [
    {
        "agent_id": "assistant",
        "data": {"message": "问题 1"}
    },
    {
        "agent_id": "translator", 
        "data": {"message": "问题 2"}
    }
]

results = asyncio.run(batch_run_agents(requests))
```

### 缓存策略

```python
import functools
import hashlib
import time

def cache_response(ttl=300):
    """缓存 API 响应"""
    def decorator(func):
        cache = {}
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = hashlib.md5(
                str(args + tuple(kwargs.items())).encode()
            ).hexdigest()
            
            # 检查缓存
            if cache_key in cache:
                cached_time, cached_result = cache[cache_key]
                if time.time() - cached_time < ttl:
                    return cached_result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache[cache_key] = (time.time(), result)
            
            return result
        
        return wrapper
    return decorator

@cache_response(ttl=600)
def run_agent_cached(agent_id: str, message: str):
    """带缓存的智能体运行"""
    # 实际的 API 调用
    return run_agent_api(agent_id, message)
```

## 监控和分析

### 请求监控

```python
import time
import logging

logger = logging.getLogger(__name__)

def monitor_api_call(func):
    """监控 API 调用性能"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            
            logger.info(f"API 调用成功: {func.__name__}, 耗时: {duration:.2f}s")
            return result
        
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"API 调用失败: {func.__name__}, 耗时: {duration:.2f}s, 错误: {e}")
            raise
    
    return wrapper

@monitor_api_call
def run_agent_with_monitoring(agent_id: str, message: str):
    """带监控的智能体运行"""
    return run_agent_api(agent_id, message)
```

### 使用分析

```python
class UsageTracker:
    def __init__(self):
        self.stats = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "total_response_time": 0
        }
    
    def record_request(self, success: bool, response_time: float):
        """记录请求统计"""
        self.stats["total_requests"] += 1
        self.stats["total_response_time"] += response_time
        
        if success:
            self.stats["successful_requests"] += 1
        else:
            self.stats["failed_requests"] += 1
    
    def get_stats(self):
        """获取使用统计"""
        total = self.stats["total_requests"]
        if total == 0:
            return self.stats
        
        avg_response_time = self.stats["total_response_time"] / total
        success_rate = self.stats["successful_requests"] / total
        
        return {
            **self.stats,
            "average_response_time": avg_response_time,
            "success_rate": success_rate
        }

# 全局使用跟踪器
usage_tracker = UsageTracker()

def tracked_api_call(agent_id: str, message: str):
    """带使用跟踪的 API 调用"""
    start_time = time.time()
    
    try:
        result = run_agent_api(agent_id, message)
        usage_tracker.record_request(True, time.time() - start_time)
        return result
    
    except Exception as e:
        usage_tracker.record_request(False, time.time() - start_time)
        raise
```

## 下一步

- 查看[认证指南](/agent-os/api/authentication)了解安全访问
- 探索[完整的 API 参考](/reference-api/overview)
- 了解[AgentOS 配置](/agent-os/config)
- 查看[部署指南](/deploy/overview)了解生产环境设置