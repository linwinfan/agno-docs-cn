---
title: "AgentOS ä¸­çš„ MCP å·¥å…·"
description: "å­¦ä¹ å¦‚ä½•åœ¨ AgentOS ä¸­çš„æ™ºèƒ½ä½“ã€å›¢é˜Ÿå’Œå·¥ä½œæµä¸­ä½¿ç”¨ MCP å·¥å…·"
mode: wide
---

[æ¨¡å‹ä¸Šä¸‹æ–‡åè®®ï¼ˆMCPï¼‰](https://modelcontextprotocol.io)ä½¿æ™ºèƒ½ä½“èƒ½å¤Ÿé€šè¿‡æ ‡å‡†åŒ–æ¥å£ä¸å¤–éƒ¨ç³»ç»Ÿäº¤äº’ã€‚

æ‚¨å¯ä»¥ä½¿ç”¨ `MCPTools` ç±»ä¸ºæ‚¨çš„æ™ºèƒ½ä½“æä¾› MCP å·¥å…·è®¿é—®æƒé™ã€‚æœ‰å…³ä½¿ç”¨ MCP å·¥å…·çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·é˜…è¯»[è¿™é‡Œ](/basics/tools/mcp/overview)ã€‚

æ‚¨çš„ `MCPTools` åœ¨ AgentOS ä¸­å°†æ­£å¸¸å·¥ä½œã€‚å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¼šè‡ªåŠ¨å¤„ç†ï¼Œæ‚¨æ— éœ€å¤„ç†è¿æ¥å’Œæ–­å¼€è¿æ¥ã€‚

<Note>
å¦‚æœæ‚¨åœ¨ AgentOS ä¸­ä½¿ç”¨ `MCPTools`ï¼Œåˆ™åœ¨æä¾› AgentOS æœåŠ¡æ—¶ä¸åº”ä½¿ç”¨ `reload=True`ã€‚
è¿™å¯èƒ½ä¼šåœ¨ FastAPI ç”Ÿå‘½å‘¨æœŸæœŸé—´ç ´å MCP è¿æ¥ã€‚
</Note>

## ç¤ºä¾‹

```python mcp_tools_example.py
from agno.agent import Agent
from agno.os import AgentOS
from agno.tools.mcp import MCPTools

# åˆ›å»º MCPTools å®ä¾‹
mcp_tools = MCPTools(
    transport="streamable-http",
    url="https://docs.agno.com/mcp"
)

# åˆ›å»ºå¯ç”¨ MCP çš„æ™ºèƒ½ä½“
agent = Agent(
    id="agno-agent",
    name="Agno æ™ºèƒ½ä½“",
    tools=[mcp_tools],
    instructions="""
    ä½ æ˜¯ä¸€ä¸ªé…å¤‡äº† MCP å·¥å…·çš„æ™ºèƒ½åŠ©æ‰‹ã€‚
    å¯ä»¥ä½¿ç”¨å„ç§å¤–éƒ¨å·¥å…·æ¥å®Œæˆä»»åŠ¡ã€‚
    è¯·æ ¹æ®ç”¨æˆ·éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·ã€‚
    """
)

# AgentOS ç®¡ç† MCP ç”Ÿå‘½å‘¨æœŸ
agent_os = AgentOS(
    description="å¸¦æœ‰ MCP å·¥å…·çš„ AgentOS",
    agents=[agent],
)

app = agent_os.get_app()

if __name__ == "__main__":
    # ä¸è¦ä½¿ç”¨ reload=True ä¸ MCP å·¥å…·ä»¥é¿å…ç”Ÿå‘½å‘¨æœŸé—®é¢˜
    agent_os.serve(app="mcp_tools_example:app")
```

## MCP å·¥å…·æ¶æ„

### æ ¸å¿ƒç»„ä»¶

```mermaid
graph TB
    A[æ™ºèƒ½ä½“] --> B[MCP å·¥å…·]
    B --> C[ä¼ è¾“å±‚]
    C --> D[MCP æœåŠ¡å™¨]
    D --> E[å¤–éƒ¨ç³»ç»Ÿ]
    
    subgraph "AgentOS é›†æˆ"
        B1[ç”Ÿå‘½å‘¨æœŸç®¡ç†] --> B2[å·¥å…·å‘ç°]
        B2 --> B3[è¯·æ±‚è·¯ç”±]
        B3 --> B4[å“åº”å¤„ç†]
    end
    
    subgraph "MCP åè®®"
        C1[HTTP ä¼ è¾“] --> C2[WebSocket ä¼ è¾“]
        C2 --> C3[æ¶ˆæ¯åºåˆ—åŒ–]
        C3 --> C4[é”™è¯¯å¤„ç†]
    end
```

## é«˜çº§é…ç½®

### 1. å¤šç§ä¼ è¾“æ–¹å¼

```python
from agno.tools.mcp import MCPTools
from agno.agent import Agent

# HTTP ä¼ è¾“
http_tools = MCPTools(
    transport="http",
    url="http://localhost:3000/mcp",
    headers={"Authorization": "Bearer token123"},
    timeout=30
)

# WebSocket ä¼ è¾“
ws_tools = MCPTools(
    transport="websocket",
    url="ws://localhost:3000/mcp",
    reconnect_interval=5,
    max_reconnect_attempts=10
)

# æµå¼ HTTP ä¼ è¾“
streamable_tools = MCPTools(
    transport="streamable-http",
    url="http://localhost:3000/mcp",
    stream_response=True,
    chunk_size=1024
)

# åˆ›å»ºå¸¦å¤šç§ä¼ è¾“çš„æ™ºèƒ½ä½“
multi_transport_agent = Agent(
    name="å¤šä¼ è¾“æ™ºèƒ½ä½“",
    tools=[http_tools, ws_tools, streamable_tools],
    instructions="""
    ä½ å¯ä»¥ä½¿ç”¨å¤šç§ä¼ è¾“æ–¹å¼è¿æ¥ä¸åŒçš„ MCP æœåŠ¡å™¨ã€‚
    æ ¹æ®ä»»åŠ¡éœ€æ±‚é€‰æ‹©æœ€åˆé€‚çš„ä¼ è¾“æ–¹å¼ã€‚
    """
)
```

### 2. è‡ªå®šä¹‰ MCP å·¥å…·é…ç½®

```python
from agno.tools.mcp import MCPTools, MCPConfig

# è‡ªå®šä¹‰ MCP é…ç½®
mcp_config = MCPConfig(
    # è¿æ¥é…ç½®
    connection_timeout=30,
    read_timeout=60,
    write_timeout=60,
    
    # é‡è¿é…ç½®
    auto_reconnect=True,
    max_reconnect_attempts=5,
    reconnect_delay=1.0,
    reconnect_backoff_factor=2.0,
    
    # ç¼“å­˜é…ç½®
    enable_cache=True,
    cache_ttl=300,  # 5 åˆ†é’Ÿ
    cache_size=1000,
    
    # æ—¥å¿—é…ç½®
    enable_logging=True,
    log_level="INFO",
    log_requests=True,
    log_responses=False,
    
    # å®‰å…¨é…ç½®
    verify_ssl=True,
    allowed_hosts=["localhost", "api.example.com"],
    api_key="your-api-key"
)

# ä½¿ç”¨è‡ªå®šä¹‰é…ç½®
custom_tools = MCPTools(
    transport="http",
    url="https://api.example.com/mcp",
    config=mcp_config
)
```

### 3. å·¥å…·å‘ç°å’Œç®¡ç†

```python
from agno.tools.mcp import MCPTools
import asyncio

class AdvancedMCPTools(MCPTools):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.discovered_tools = {}
        self.tool_usage_stats = {}
    
    async def discover_tools(self):
        """å‘ç°å¯ç”¨å·¥å…·"""
        try:
            tools = await self.list_tools()
            
            for tool in tools:
                tool_name = tool['name']
                self.discovered_tools[tool_name] = {
                    'description': tool.get('description', ''),
                    'input_schema': tool.get('inputSchema', {}),
                    'last_seen': asyncio.get_event_loop().time()
                }
                
                # åˆå§‹åŒ–ä½¿ç”¨ç»Ÿè®¡
                if tool_name not in self.tool_usage_stats:
                    self.tool_usage_stats[tool_name] = {
                        'usage_count': 0,
                        'success_count': 0,
                        'error_count': 0,
                        'avg_response_time': 0.0
                    }
            
            print(f"å‘ç° {len(tools)} ä¸ªå·¥å…·")
            return tools
            
        except Exception as e:
            print(f"å·¥å…·å‘ç°å¤±è´¥: {e}")
            return []
    
    async def get_tool_recommendations(self, task_description):
        """æ ¹æ®ä»»åŠ¡æè¿°æ¨èå·¥å…·"""
        recommendations = []
        
        for tool_name, tool_info in self.discovered_tools.items():
            description = tool_info['description'].lower()
            task_desc = task_description.lower()
            
            # ç®€å•çš„å…³é”®è¯åŒ¹é…
            if any(keyword in description for keyword in task_desc.split()):
                recommendations.append({
                    'tool': tool_name,
                    'description': tool_info['description'],
                    'confidence': self._calculate_confidence(description, task_desc)
                })
        
        # æŒ‰ç½®ä¿¡åº¦æ’åº
        recommendations.sort(key=lambda x: x['confidence'], reverse=True)
        
        return recommendations[:5]  # è¿”å›å‰5ä¸ªæ¨è
    
    def _calculate_confidence(self, tool_desc, task_desc):
        """è®¡ç®—æ¨èç½®ä¿¡åº¦"""
        common_words = set(tool_desc.split()) & set(task_desc.split())
        total_words = len(set(task_desc.split()))
        
        if total_words == 0:
            return 0.0
        
        return len(common_words) / total_words
    
    async def track_tool_usage(self, tool_name, success=True, response_time=0.0):
        """è·Ÿè¸ªå·¥å…·ä½¿ç”¨æƒ…å†µ"""
        if tool_name in self.tool_usage_stats:
            stats = self.tool_usage_stats[tool_name]
            stats['usage_count'] += 1
            
            if success:
                stats['success_count'] += 1
            else:
                stats['error_count'] += 1
            
            # æ›´æ–°å¹³å‡å“åº”æ—¶é—´
            total_time = stats['avg_response_time'] * (stats['usage_count'] - 1) + response_time
            stats['avg_response_time'] = total_time / stats['usage_count']
    
    def get_usage_report(self):
        """è·å–ä½¿ç”¨æŠ¥å‘Š"""
        report = {}
        
        for tool_name, stats in self.tool_usage_stats.items():
            if stats['usage_count'] > 0:
                success_rate = stats['success_count'] / stats['usage_count']
                
                report[tool_name] = {
                    'usage_count': stats['usage_count'],
                    'success_rate': f"{success_rate:.2%}",
                    'avg_response_time': f"{stats['avg_response_time']:.3f}s",
                    'error_count': stats['error_count']
                }
        
        return report

# ä½¿ç”¨é«˜çº§ MCP å·¥å…·
advanced_tools = AdvancedMCPTools(
    transport="http",
    url="https://api.example.com/mcp"
)
```

## å›¢é˜Ÿå’Œå·¥ä½œæµé›†æˆ

### 1. å›¢é˜Ÿä¸­çš„ MCP å·¥å…·

```python
from agno.agent import Agent
from agno.team import Team
from agno.tools.mcp import MCPTools

# åˆ›å»ºä¸“é—¨çš„ MCP å·¥å…·é›†
file_tools = MCPTools(
    transport="http",
    url="http://localhost:3001/mcp",
    name="file-operations"
)

database_tools = MCPTools(
    transport="websocket", 
    url="ws://localhost:3002/mcp",
    name="database-operations"
)

api_tools = MCPTools(
    transport="streamable-http",
    url="https://api.example.com/mcp",
    name="api-operations"
)

# åˆ›å»ºä¸“é—¨è§’è‰²çš„æ™ºèƒ½ä½“
file_agent = Agent(
    name="æ–‡ä»¶ç®¡ç†å‘˜",
    tools=[file_tools],
    instructions="è´Ÿè´£æ–‡ä»¶æ“ä½œå’Œç®¡ç†"
)

db_agent = Agent(
    name="æ•°æ®åº“ç®¡ç†å‘˜", 
    tools=[database_tools],
    instructions="è´Ÿè´£æ•°æ®åº“æŸ¥è¯¢å’Œç»´æŠ¤"
)

api_agent = Agent(
    name="API é›†æˆä¸“å®¶",
    tools=[api_tools],
    instructions="è´Ÿè´£å¤–éƒ¨ API è°ƒç”¨å’Œæ•°æ®é›†æˆ"
)

# åˆ›å»ºåä½œå›¢é˜Ÿ
operations_team = Team(
    name="è¿ç»´å›¢é˜Ÿ",
    agents=[file_agent, db_agent, api_agent],
    instructions="""
    æˆ‘ä»¬æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è¿ç»´å›¢é˜Ÿï¼Œåä½œå¤„ç†å„ç§ç³»ç»Ÿæ“ä½œä»»åŠ¡ã€‚
    æ ¹æ®ä»»åŠ¡ç±»å‹è‡ªåŠ¨åˆ†é…ç»™åˆé€‚çš„ä¸“å®¶ã€‚
    ç¡®ä¿æ“ä½œçš„å®‰å…¨æ€§å’Œæ•ˆç‡ã€‚
    """
)

# é›†æˆåˆ° AgentOS
agent_os = AgentOS(
    agents=[file_agent, db_agent, api_agent, operations_team],
    enable_mcp_server=True
)
```

### 2. å·¥ä½œæµä¸­çš„ MCP å·¥å…·

```python
from agno.workflow import Workflow, WorkflowStep
from agno.tools.mcp import MCPTools

# åˆ›å»ºå·¥ä½œæµæ­¥éª¤
class DataIngestionStep(WorkflowStep):
    def __init__(self, mcp_tools):
        super().__init__()
        self.mcp_tools = mcp_tools
    
    async def run(self, input_data):
        """æ•°æ®æ‘„å–æ­¥éª¤"""
        # ä½¿ç”¨ MCP å·¥å…·è¿æ¥æ•°æ®æº
        data_source = input_data.get("data_source")
        
        # å‘ç°å¹¶ä½¿ç”¨åˆé€‚çš„å·¥å…·
        tools = await self.mcp_tools.discover_tools()
        recommendations = await self.mcp_tools.get_tool_recommendations(
            f"è¿æ¥åˆ° {data_source} æ•°æ®æº"
        )
        
        if recommendations:
            best_tool = recommendations[0]['tool']
            
            try:
                result = await self.mcp_tools.call_tool(best_tool, {
                    "action": "connect",
                    "source": data_source
                })
                
                return {
                    "status": "success",
                    "data": result,
                    "tool_used": best_tool
                }
                
            except Exception as e:
                return {
                    "status": "error", 
                    "error": str(e),
                    "tool_used": best_tool
                }
        
        return {"status": "no_tools_available"}

class DataProcessingStep(WorkflowStep):
    def __init__(self, mcp_tools):
        super().__init__()
        self.mcp_tools = mcp_tools
    
    async def run(self, input_data):
        """æ•°æ®å¤„ç†æ­¥éª¤"""
        raw_data = input_data.get("data")
        processing_type = input_data.get("processing_type", "transform")
        
        # è·å–æ•°æ®å¤„ç†å·¥å…·
        recommendations = await self.mcp_tools.get_tool_recommendations(
            f"æ•°æ® {processing_type} å¤„ç†"
        )
        
        results = []
        
        for recommendation in recommendations[:3]:  # å°è¯•å‰3ä¸ªæ¨èå·¥å…·
            tool_name = recommendation['tool']
            
            try:
                result = await self.mcp_tools.call_tool(tool_name, {
                    "data": raw_data,
                    "operation": processing_type
                })
                
                results.append({
                    "tool": tool_name,
                    "result": result,
                    "success": True
                })
                
            except Exception as e:
                results.append({
                    "tool": tool_name,
                    "error": str(e),
                    "success": False
                })
        
        return {"processing_results": results}

# åˆ›å»ºå·¥ä½œæµ
data_workflow = Workflow(
    name="æ•°æ®å¤„ç†å·¥ä½œæµ",
    steps=[
        DataIngestionStep(mcp_tools),
        DataProcessingStep(mcp_tools)
    ]
)

# é›†æˆåˆ° AgentOS
agent_os = AgentOS(
    workflows=[data_workflow],
    agents=[file_agent, db_agent, api_agent],
    enable_mcp_server=True
)
```

## ç›‘æ§å’Œè°ƒè¯•

### 1. MCP å·¥å…·ç›‘æ§

```python
import time
import asyncio
from collections import defaultdict
from typing import Dict, List, Any

class MCPToolsMonitor:
    def __init__(self):
        self.metrics = defaultdict(lambda: {
            "call_count": 0,
            "success_count": 0,
            "error_count": 0,
            "total_response_time": 0.0,
            "last_called": None
        })
    
    async def track_tool_call(self, tool_name: str, success: bool, response_time: float):
        """è·Ÿè¸ªå·¥å…·è°ƒç”¨"""
        metrics = self.metrics[tool_name]
        metrics["call_count"] += 1
        metrics["last_called"] = time.time()
        metrics["total_response_time"] += response_time
        
        if success:
            metrics["success_count"] += 1
        else:
            metrics["error_count"] += 1
    
    def get_performance_report(self) -> Dict[str, Any]:
        """è·å–æ€§èƒ½æŠ¥å‘Š"""
        report = {}
        
        for tool_name, metrics in self.metrics.items():
            if metrics["call_count"] > 0:
                success_rate = metrics["success_count"] / metrics["call_count"]
                avg_response_time = metrics["total_response_time"] / metrics["call_count"]
                
                report[tool_name] = {
                    "call_count": metrics["call_count"],
                    "success_rate": f"{success_rate:.2%}",
                    "avg_response_time": f"{avg_response_time:.3f}s",
                    "error_count": metrics["error_count"],
                    "last_called": time.strftime(
                        "%Y-%m-%d %H:%M:%S", 
                        time.localtime(metrics["last_called"])
                    ) if metrics["last_called"] else "Never"
                }
        
        return report
    
    def identify_problematic_tools(self, error_threshold=0.1) -> List[str]:
        """è¯†åˆ«æœ‰é—®é¢˜çš„å·¥å…·"""
        problematic = []
        
        for tool_name, metrics in self.metrics.items():
            if metrics["call_count"] > 0:
                error_rate = metrics["error_count"] / metrics["call_count"]
                if error_rate > error_threshold:
                    problematic.append(tool_name)
        
        return problematic

# é›†æˆç›‘æ§åˆ° MCP å·¥å…·
monitor = MCPToolsMonitor()

class MonitoredMCPTools(MCPTools):
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]):
        """å¸¦ç›‘æ§çš„å·¥å…·è°ƒç”¨"""
        start_time = time.time()
        success = False
        
        try:
            result = await super().call_tool(tool_name, arguments)
            success = True
            return result
            
        except Exception as e:
            success = False
            raise
            
        finally:
            response_time = time.time() - start_time
            await monitor.track_tool_call(tool_name, success, response_time)
```

### 2. è°ƒè¯•å·¥å…·

```python
import json
import asyncio
from typing import Dict, Any

class MCPToolsDebugger:
    def __init__(self, mcp_tools: MCPTools):
        self.mcp_tools = mcp_tools
    
    async def test_connection(self):
        """æµ‹è¯•è¿æ¥"""
        try:
            # å°è¯•åˆ—å‡ºå·¥å…·æ¥æµ‹è¯•è¿æ¥
            tools = await self.mcp_tools.list_tools()
            print(f"âœ… è¿æ¥æˆåŠŸï¼Œå‘ç° {len(tools)} ä¸ªå·¥å…·")
            return True
            
        except Exception as e:
            print(f"âŒ è¿æ¥å¤±è´¥: {e}")
            return False
    
    async def test_tool_availability(self):
        """æµ‹è¯•å·¥å…·å¯ç”¨æ€§"""
        try:
            tools = await self.mcp_tools.list_tools()
            
            print("ğŸ”§ æµ‹è¯•å·¥å…·å¯ç”¨æ€§:")
            available_count = 0
            
            for tool in tools:
                tool_name = tool['name']
                
                try:
                    # å°è¯•è·å–å·¥å…·æ¨¡å¼
                    schema = tool.get('inputSchema', {})
                    print(f"âœ… {tool_name}: å¯ç”¨")
                    available_count += 1
                    
                except Exception as e:
                    print(f"âŒ {tool_name}: ä¸å¯ç”¨ - {e}")
            
            print(f"\nğŸ“Š å¯ç”¨å·¥å…·: {available_count}/{len(tools)}")
            return available_count == len(tools)
            
        except Exception as e:
            print(f"âŒ å·¥å…·å¯ç”¨æ€§æµ‹è¯•å¤±è´¥: {e}")
            return False
    
    async def test_tool_functionality(self, tool_name: str, test_args: Dict[str, Any] = None):
        """æµ‹è¯•å·¥å…·åŠŸèƒ½"""
        try:
            if test_args is None:
                test_args = self._get_default_test_args(tool_name)
            
            print(f"ğŸ§ª æµ‹è¯•å·¥å…·: {tool_name}")
            print(f"ğŸ“ æµ‹è¯•å‚æ•°: {test_args}")
            
            start_time = time.time()
            result = await self.mcp_tools.call_tool(tool_name, test_args)
            response_time = time.time() - start_time
            
            print(f"âœ… {tool_name} æµ‹è¯•æˆåŠŸ")
            print(f"â±ï¸ å“åº”æ—¶é—´: {response_time:.3f}s")
            print(f"ğŸ“„ ç»“æœ: {json.dumps(result, indent=2, ensure_ascii=False)[:200]}...")
            
            return True
            
        except Exception as e:
            print(f"âŒ {tool_name} æµ‹è¯•å¤±è´¥: {e}")
            return False
    
    def _get_default_test_args(self, tool_name: str) -> Dict[str, Any]:
        """è·å–é»˜è®¤æµ‹è¯•å‚æ•°"""
        tool_name_lower = tool_name.lower()
        
        if 'search' in tool_name_lower:
            return {"query": "æµ‹è¯•æœç´¢"}
        elif 'calculate' in tool_name_lower:
            return {"expression": "2 + 2"}
        elif 'file' in tool_name_lower:
            return {"action": "list", "path": "."}
        elif 'database' in tool_name_lower:
            return {"query": "SELECT 1"}
        else:
            return {"test": True}
    
    async def run_comprehensive_test(self):
        """è¿è¡Œç»¼åˆæµ‹è¯•"""
        print("ğŸš€ å¼€å§‹ MCP å·¥å…·ç»¼åˆæµ‹è¯•")
        print("=" * 60)
        
        # æµ‹è¯•è¿æ¥
        connection_ok = await self.test_connection()
        if not connection_ok:
            return False
        
        # æµ‹è¯•å·¥å…·å¯ç”¨æ€§
        availability_ok = await self.test_tool_availability()
        
        # æµ‹è¯•å·¥å…·åŠŸèƒ½
        tools = await self.mcp_tools.list_tools()
        functionality_tests = []
        
        for tool in tools[:3]:  # åªæµ‹è¯•å‰3ä¸ªå·¥å…·
            tool_name = tool['name']
            test_ok = await self.test_tool_functionality(tool_name)
            functionality_tests.append(test_ok)
        
        print("=" * 60)
        print("ğŸ“Š æµ‹è¯•ç»“æœ:")
        print(f"è¿æ¥: {'âœ… æ­£å¸¸' if connection_ok else 'âŒ å¼‚å¸¸'}")
        print(f"å¯ç”¨æ€§: {'âœ… æ­£å¸¸' if availability_ok else 'âŒ å¼‚å¸¸'}")
        print(f"åŠŸèƒ½æ€§: {'âœ… æ­£å¸¸' if all(functionality_tests) else 'âŒ å¼‚å¸¸'}")
        
        return connection_ok and availability_ok and all(functionality_tests)

# ä½¿ç”¨è°ƒè¯•å·¥å…·
async def debug_mcp_tools():
    mcp_tools = MCPTools(
        transport="http",
        url="http://localhost:3000/mcp"
    )
    
    debugger = MCPToolsDebugger(mcp_tools)
    await debugger.run_comprehensive_test()

if __name__ == "__main__":
    asyncio.run(debug_mcp_tools())
```

## æœ€ä½³å®è·µ

### 1. å·¥å…·ç®¡ç†

- **å·¥å…·å‘ç°**: å®šæœŸå‘ç°å’Œæ›´æ–°å¯ç”¨å·¥å…·åˆ—è¡¨
- **ä½¿ç”¨ç»Ÿè®¡**: è·Ÿè¸ªå·¥å…·ä½¿ç”¨æƒ…å†µä»¥ä¼˜åŒ–é…ç½®
- **é”™è¯¯å¤„ç†**: å®æ–½ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- **æ€§èƒ½ç›‘æ§**: ç›‘æ§å·¥å…·å“åº”æ—¶é—´å’ŒæˆåŠŸç‡

### 2. è¿æ¥ç®¡ç†

- **è¿æ¥æ± **: ä½¿ç”¨è¿æ¥æ± æé«˜æ€§èƒ½
- **è‡ªåŠ¨é‡è¿**: å®æ–½è‡ªåŠ¨é‡è¿æœºåˆ¶
- **è¶…æ—¶è®¾ç½®**: è®¾ç½®åˆç†çš„è¿æ¥å’Œè¯»å†™è¶…æ—¶
- **è´Ÿè½½å‡è¡¡**: åœ¨å¤šä¸ªæœåŠ¡å™¨é—´åˆ†é…è´Ÿè½½

### 3. å®‰å…¨è€ƒè™‘

- **èº«ä»½éªŒè¯**: ä½¿ç”¨å¼ºèº«ä»½éªŒè¯æœºåˆ¶
- **æˆæƒæ§åˆ¶**: å®æ–½ç»†ç²’åº¦çš„æƒé™æ§åˆ¶
- **æ•°æ®åŠ å¯†**: åŠ å¯†æ•æ„Ÿæ•°æ®ä¼ è¾“
- **è®¿é—®æ—¥å¿—**: è®°å½•è¯¦ç»†çš„è®¿é—®æ—¥å¿—

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### è¿æ¥å¤±è´¥

**é—®é¢˜**: MCP å·¥å…·æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨
**è§£å†³æ–¹æ¡ˆ**:
1. æ£€æŸ¥æœåŠ¡å™¨ URL å’Œç«¯å£
2. éªŒè¯ç½‘ç»œè¿æ¥å’Œé˜²ç«å¢™è®¾ç½®
3. æ£€æŸ¥èº«ä»½éªŒè¯å‡­æ®
4. ç¡®è®¤æœåŠ¡å™¨çŠ¶æ€

#### å·¥å…·è°ƒç”¨å¤±è´¥

**é—®é¢˜**: å·¥å…·è°ƒç”¨è¿”å›é”™è¯¯
**è§£å†³æ–¹æ¡ˆ**:
1. æ£€æŸ¥å·¥å…·åç§°å’Œå‚æ•°æ ¼å¼
2. éªŒè¯å·¥å…·å¯ç”¨æ€§
3. æŸ¥çœ‹æœåŠ¡å™¨æ—¥å¿—
4. æµ‹è¯•å·¥å…·ç‹¬ç«‹åŠŸèƒ½

#### æ€§èƒ½é—®é¢˜

**é—®é¢˜**: å·¥å…·å“åº”æ—¶é—´è¿‡é•¿
**è§£å†³æ–¹æ¡ˆ**:
1. å¯ç”¨è¿æ¥ç¼“å­˜
2. ä¼˜åŒ–ç½‘ç»œé…ç½®
3. è°ƒæ•´è¶…æ—¶è®¾ç½®
4. è€ƒè™‘è´Ÿè½½å‡è¡¡

## ä¸‹ä¸€æ­¥

- æŸ¥çœ‹[MCP æ¦‚è¿°](/agent-os/mcp/mcp)
- äº†è§£[AgentOS é…ç½®](/agent-os/config)
- æ¢ç´¢[ä¸­é—´ä»¶åŠŸèƒ½](/agent-os/middleware)
- æŸ¥çœ‹[å®‰å…¨åŠŸèƒ½](/agent-os/security)