---
title: JWT 中间件
sidebarTitle: JWT
description: 使用 JWT 令牌验证和 RBAC 保护您的 AgentOS 应用程序
keywords: [jwt 中间件, jwt 身份验证, 令牌验证, 参数注入, 授权, bearer 令牌, jwt 声明, http only cookies, 令牌验证, jwt 密钥, 用户身份验证, 会话管理, jwt 令牌, pyjwt, 令牌安全, rbac, 范围, 基于角色的访问控制]
---

<Badge icon="code-branch" color="orange">
    <Tooltip tip="Introduced in v2.1.0" cessaging="View release notes" href="https://github.com/agno-agi/agno/releases/tag/v2.1.0">v2.1.0</Tooltip>
</Badge>

使用 JWT 令牌对您的 AgentOS 应用程序进行身份验证和授权。中间件从 Authorization 头部或 cookies 中提取令牌，验证它们，并自动将 user_id、session_id 和自定义声明注入到您的端点中。

JWT 中间件提供三个主要功能：
1. **令牌验证**: 验证 JWT 令牌并处理身份验证
2. **参数注入**: 自动将 user_id、session_id 和自定义声明注入端点参数
3. **RBAC 授权**: 验证每个端点所需权限的范围

```python jwt_middleware_setup.py
from agno.os.middleware import JWTMiddleware
from agno.os.middleware.jwt import TokenSource

app.add_middleware(
    JWTMiddleware,
    verification_keys=["your-jwt-verification-key"],  # 或使用 JWT_VERIFICATION_KEY 环境变量
    algorithm="RS256",  # RS256 用于非对称密钥，HS256 用于对称密钥
    user_id_claim="sub",  # 从 'sub' 声明中提取 user_id
    session_id_claim="session_id",  # 从声明中提取 session_id
    dependencies_claims=["name", "email", "roles"],  # 附加声明
    validate=True,  # 启用令牌验证
    authorization=True,  # 启用 RBAC 范围检查
    verify_audience=True,  # 验证 `aud` 声明是否匹配 AgentOS ID
)
```

## 令牌源

中间件支持三种令牌源：

<Tabs>
  <Tab title="Authorization 头部">
    从 `Authorization: Bearer <token>` 头部提取 JWT。
    
    ```python
    from agno.os.middleware.jwt import TokenSource
    
    app.add_middleware(
        JWTMiddleware,
        token_source=TokenSource.HEADER
    )
    ```
    
    这是标准的 JWT 令牌传递方式，推荐用于 API 访问。
  </Tab>
  
  <Tab title="Cookie">
    从 HTTP cookies 中提取 JWT。
    
    ```python
    app.add_middleware
        JWTMiddleware(
            token_source=TokenSource.COOKIE
        )
    ```
    
    适用于 Web 应用和客户端应用。
  </Tab>
  
  <Tab title="自定义">
    使用自定义函数提取令牌。
    
    ```python
    def custom_token_extractor(request):
        return request.headers.get("X-Custom-Token")
    
    app.add_middleware(
        JWTMiddleware,
        token_source=custom_token_extractor
    )
    ```
    
    适用于特殊的认证需求。
  </Tab>
</Tabs>

## 配置选项

### 1. 基本配置

```python
from agno.os.middleware import JWTMiddleware

# 基本 JWT 配置
jwt_middleware = JWTMiddleware(
    secret_key="your-secret-key",  # 对称密钥
    algorithm="HS256",              # 算法：HS256 或 RS256
    user_id_claim="sub",              # 用户 ID 声明
    session_id_claim="session_id",        # 会话 ID 声明
    dependencies_claims=["roles"],       # 依赖声明
    exclude_paths=["/health", "/docs"],   # 排除路径
    auto_error=True,                 # 自动返回错误响应
    verify_audience=True,             # 验证受众
    token_source=TokenSource.HEADER
)
```

### 2. 高级配置

```python
from agno.os.middleware import JWTMiddleware
from agno.os.middleware.jwt import TokenSource

# 高级 JWT 配置
jwt_middleware = JWTMiddleware(
    # 密钥配置
    secret_key="your-secret-key",
    algorithm="RS256",
    verification_keys=["key1", "key2"],  # 支持多密钥轮换
    
    # 声明配置
    user_id_claim="sub",
    session_id_claim="session_id",
    role_claim="roles",
    scope_claim="scopes",
    audience_claim="aud",
    issuer_claim="iss",
    
    # 依赖声明
    dependencies_claims=["email", "name", "permissions"],
    
    # 验证配置
    validate=True,
    verify_audience=True,
    verify_exp=True,  # 验证过期时间
    verify_iat=True,   # 验证签发时间
    verify_nbf=True,    # 验证不可使用时间
    
    # 授权配置
    authorization=True,
    default_scopes=["read", "write"],  # 默认权限范围
    scope_separator=" ",              # 范围分隔符
    
    # 令牌源
    token_source=TokenSource.HEADER,
    
    # 排除路径
    exclude_paths=["/health", "/metrics", "/docs", "/openapi.json"],
    
    # 错误处理
    auto_error=True,
    error_message="认证失败",
    error_status_code=401
)
```

### 3. 环境变量配置

```bash
# JWT 配置环境变量
export JWT_SECRET_KEY="your-secret-key"
export JWT_VERIFICATION_KEY="your-verification-key"
export JWT_ALGORITHM="RS256"
export JWT_USER_ID_CLAIM="sub"
export JWT_SESSION_ID_CLAIM="session_id"
export JWT_ROLE_CLAIM="roles"
export JWT_SCOPE_CLAIM="scopes"
export JWT_AUDIENCE_CLAIM="aud"
export JWT_ISSUER_CLAIM="iss"
```

## RBAC 授权

### 1. 基于角色的访问控制

```python
from agno.agent import Agent
from agno.os import AgentOS
from agno.os.middleware import JWTMiddleware

# 创建需要特定角色的智能体
admin_agent = Agent(
    name="管理员智能体",
    instructions="你具有管理员权限，可以执行所有操作"
)

user_agent = Agent(
    name="用户智能体", 
    instructions="你具有用户权限，只能执行基本操作"
)

# 配置 JWT 中间件
jwt_middleware = JWTMiddleware(
    secret_key="your-secret-key",
    authorization=True,
    default_scopes=["read", "write"],
    scope_separator=" "
)

# 创建 AgentOS
agent_os = AgentOS(
    agents=[admin_agent, user_agent],
    middleware=[jwt_middleware]
)

# 在端点中验证权限
@app.get("/admin/users")
async def get_users(
    current_user: Annotated[str, Depends(get_current_user)],
    required_scopes=["admin", "read"]
):
    # 只有具有 admin 权限的用户才能访问
    pass

@app.get("/user/profile")
async def get_profile(
    current_user: Annotated[str, Depends(get_current_user)],
    required_scopes=["user", "read"]
):
    # 具有用户权限的用户可以访问
    pass
```

### 2. 细粒度权限控制

```python
from typing import List, Optional
from fastapi import Depends
from agno.agent import Agent
from agno.os import AgentOS

# 权限定义
PERMISSIONS = {
    "user:read": "读取用户信息",
    "user:write": "修改用户信息",
    "content:read": "读取内容",
    "content:write": "创建或修改内容",
    "system:admin": "系统管理",
    "analytics:read": "查看分析数据",
    "analytics:write": "修改分析数据"
}

# 权限检查装饰器
def require_permissions(required_permissions: List[str]):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # 这里应该检查用户权限
            # 实际实现需要结合 JWT 中间件
            return await func(*args, **kwargs)
        return wrapper
    return decorator

class PermissionManager:
    def __init__(self, current_user):
        self.current_user = current_user
    
    def has_permission(self, permission: str) -> bool:
        """检查用户是否具有特定权限"""
        if not self.current_user:
            return False
        
        permissions = self.current_user.get("permissions", [])
        return permission in permissions
    
    def has_any_permission(self, permissions: List[str]) -> bool:
        """检查用户是否具有任一权限"""
        if not self.current_user:
            return False
        
        user_permissions = self.get("permissions", [])
        return any(perm in user_permissions for perm in permissions)
    
    def has_all_permissions(self, permissions: List[str]) -> bool:
        """检查用户是否具有所有权限"""
        if not self.current_user:
            return False
        
        user_permissions = self.get("permissions", [])
        return all(perm in user_permissions for perm in permissions)

# 在智能体中使用权限管理
@Agent
def create_permission_aware_agent():
    agent = Agent(
        name="权限感知智能体",
        instructions="""
        你是一个具有权限感知的智能体。
        根据用户权限执行相应的操作。
        """
    )
    
    async def run(self, message: str, user_id: Optional[str] = None) -> str:
        # 检查用户权限
        permission_manager = PermissionManager({"user_id": user_id})
        
        if not permission_manager.has_permission("content:read"):
            return "抱歉，您没有读取内容的权限"
        
        # 执行受保护的操作
        return await super().run(message, user_id)

# 创建带权限的 AgentOS
agent_os = AgentOS(
    agents=[create_permission_aware_agent()],
    middleware=[jwt_middleware]
)
```

## 令牌生成和验证

### 1. 令牌生成

```python
import jwt
import time
from datetime import datetime, timedelta
from typing import Dict, Any
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

class JWTTokenManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
    
    def generate_token(self, payload: Dict[str, Any], expiry_hours: int = 24) -> str:
        """生成 JWT 令牌"""
        now = datetime.utcnow()
        exp = now + timedelta(hours=expiry_hours)
        
        payload.update({
            "exp": exp,
            "iat": now,
            "jti": str(uuid.uuid4())  # JWT ID
        })
        
        return jwt.encode(
            payload,
            self.secret_key,
            algorithm=self.algorithm
        )
    
    def generate_token_pair(self, user_id: str, permissions: List[str], 
                        expiry_hours: int = 24) -> Dict[str, str]:
        """生成访问令牌和刷新令牌对"""
        access_payload = {
            "sub": user_id,
            "session_id": str(uuid.uuid4()),
            "roles": permissions,
            "scopes": permissions,
            "type": "access",
            "exp": datetime.utcnow() + timedelta(hours=1)  # 访问令牌 1 小时
        }
        
        refresh_payload = {
            "sub": user_id,
            "session_id": str(uuid.uuid4()),
            "type": "refresh",
            "exp": datetime.utcnow() + timedelta(days=7)  # 刷新令牌 7 天
        }
        
        access_token = self.generate_token(access_payload)
        refresh_token = self.generate_token(refresh_payload)
        
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_type": "Bearer",
            "expires_in": 3600
        }
    
    def validate_token(self, token: str) -> Dict[str, Any]:
        """验证 JWT 令牌"""
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            return {
                "valid": True,
                "payload": payload
            }
        except jwt.ExpiredSignatureError:
            return {
                "valid": False,
                "error": "令牌已过期"
            }
        except jwt.InvalidTokenError:
            return {
                "valid": False,
                "error": "无效令牌格式"
            }
        except Exception as e:
            return {
                "token_source": str(e)
            }
    
    def refresh_token(self, refresh_token: str) -> Dict[str, str]:
        """刷新访问令牌"""
        try:
            payload = jwt.decode(
                refresh_token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            
            # 生成新的访问令牌
            new_payload = {
                "sub": payload["sub"],
                "session_id": payload.get("session_id"),
                "roles": payload.get("roles"),
                "scopes": payload.get("scopes"),
                "type": "access",
                "iat": datetime.utcnow(),
                "exp": datetime.utcnow() + timedelta(hours=1)
            }
            
            new_token = jwt.encode(
                new_payload,
                self.secret_key,
                algorithm=self.algorithm
            )
            
            return {
                "access_token": new_token,
                "token_type": "Bearer",
                "expires_in": 3600
            }
            
        except Exception as e:
            return {
                "error": f"令牌刷新失败: {str(e)}"
            }
```

### 2. 令牌验证中间件示例

```python
from fastapi import HTTPException
from fastapi.security import HTTPBearer
from agno.os.middleware.jwt import JWTMiddleware

class EnhancedJWTMiddleware(JWTMiddleware):
    def __init__(self, app, **kwargs):
        super().__init__(app, **kwargs)
        self.token_manager = JWTTokenManager(
            secret_key=kwargs.get("secret_key", "default-secret"),
            algorithm=kwargs.get("algorithm", "HS256")
        )
    
    async def dispatch(self, request, call_next):
        # 获取令牌
        token = self._extract_token(request)
        
        if not token:
            raise HTTPException(
                status_code=401,
                detail="缺少认证令牌"
            )
        
        # 验证令牌
        validation_result = self.token_manager.validate_token(token)
        
        if not validation_result["valid"]:
            raise HTTPException(
                status_code=401,
                detail=validation_result["error"]
            )
        
        # 添加用户信息到请求状态
        payload = validation_result["payload"]
        request.state.user_id = payload.get("sub")
        request.state.session_id = payload.get("session_id")
        request.state.roles = payload.get("roles", [])
        request_state.scopes = payload.get("scopes", [])
        
        response = await call_next(request)
        return response
    
    def _extract_token(self, request):
        """从请求中提取令牌"""
        # 从 Authorization 头部提取
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            return auth_header[7:]  # 移除 "Bearer "
        
        # 从 Cookie 提取
        token_cookie = request.cookies.get("access_token")
        if token_cookie:
            return token_cookie
        
        return None
```

## 会话管理

### 1. 会话中间件

```python
import uuid
import time
from typing import Dict, Any
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

class SessionMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, session_ttl: int = 3600):
        super().__init__(app)
        self.session_ttl = session_ttl
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
    
    async def dispatch(self, request: request, call_next):
        # 获取或创建会话 ID
        session_id = self._get_or_create_session_id(request)
        
        # 添加会话信息到请求状态
        request.state.session_id = session_id
        request.state.session_start_time = time.time()
        
        response = await call_next(request)
        
        # 更新会话活动时间
        if session_id in self.active_sessions:
            self.active_sessions[session_id]["last_activity"] = time.time()
        
        return response
    
    def _get_or_create_session_id(self, request) -> str:
        """获取或创建会话 ID"""
        # 从请求中获取会话 ID
        session_id = request.headers.get("X-Session-ID")
        
        if not session_id:
            # 创建新会话 ID
            session_id = str(uuid.uuid4())
        
        # 记录或更新会话信息
        if session_id not in self.active_sessions:
            self.active_sessions[session_id] = {
                "created_at": time.time(),
                "last_activity": time.time(),
                "request_count": 0
            }
        
        return session_id
    
    def cleanup_expired_sessions(self):
        """清理过期会话"""
        current_time = time.time()
        expired_sessions = [
            session_id for session_id, session in self.active_sessions.items()
            if current_time - session["last_activity"] > self.session_ttl
        ]
        
        for session_id in expired_sessions:
            del self.active_sessions[session_id]
    
    def get_session_info(self, session_id: str) -> Dict[str, Any]:
        """获取会话信息"""
        return self.active_sessions.get(session_id, {})
```

### 2. 会话管理器

```python
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

class SessionManager:
    def __init__(self):
        self.sessions: Dict[str, Dict[str, Any]] = {}
        self.session_ttl = 3600  # 1 小时
    
    def create_session(self, user_id: str, metadata: Dict[str, Any] = None) -> str:
        """创建新会话"""
        session_id = str(uuid.uuid4())
        
        session_data = {
            "session_id": session_id,
            "user_id": user_id,
            "created_at": datetime.utcnow(),
            "last_activity": datetime.utcnow(),
            "metadata": metadata or {},
            "is_active": True
        }
        
        self.sessions[session_id] = session_data
        return session_id
    
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话信息"""
        return self.sessions.get(session_id)
    
    def update_session_activity(self, session_id: str):
        """更新会话活动时间"""
        if session_id in self.sessions:
            self.sessions[session_id]["last_activity"] = datetime.utcnow()
    
    def is_session_valid(self, session_id: str) -> bool:
        """检查会话是否有效"""
        session = self.sessions.get(session_id)
        if not session:
            return False
        
        if not session.get("is_active", True):
            return False
        
        return (datetime.utcnow() - session["last_activity"]) < self.session_ttl
    
    def invalidate_session(self, session_id: str):
        """使会话失效"""
        if session_id in self.sessions:
            self.sessions[session_id]["is_active"] = False
    
    def cleanup_expired_sessions(self):
        """清理过期会话"""
        current_time = datetime.utcnow()
        expired_sessions = [
            session_id for session_id, session in self.sessions.items()
            if (current_time - session["last_activity"]) > self.session_ttl
        ]
        
        for session_id in expired_sessions:
            del self.sessions[session_id]
```

## 监控和分析

### 1. JWT 性能监控

```python
import time
import asyncio
from collections import defaultdict
from typing import Dict, List, Any

class JWTPerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(lambda: {
            "validation_count": 0,
            "validation_time_total": 0.0,
            "error_count": 0,
            "success_count": 0,
            "token_source_stats": defaultdict(int),
            "user_activity": defaultdict(int)
        })
    
    async def track_validation(self, token_source: str, validation_time: float, success: bool):
        """跟踪令牌验证性能"""
        self.metrics["validation_count"] += 1
        self.metrics["validation_time_total"] += validation_time
        self.metrics["token_source_stats"][token_source] += 1
        
        if success:
            self.metrics["success_count"] += 1
        else:
            self.metrics["error_count"] += 1
    
    def get_performance_report(self) -> Dict[str, Any]:
        """获取性能报告"""
        if self.metrics["validation_count"] > 0:
            avg_validation_time = (
                self.metrics["validation_time_total"] / self.metrics["validation_count"]
            )
            error_rate = (
                self.metrics["error_count"] / self.metrics["validation_count"]
            )
            
            return {
                "total_validations": self.metrics["validation_count"],
                "avg_validation_time": f"{avg_validation_time:.3f}s",
                "error_rate": f"{error_rate:.2%}",
                "token_source_distribution": dict(self.metrics["token_source_stats"]),
                "user_activity_count": len(self.metrics["user_activity"])
            }
        
        return {}
    
    def identify_problematic_sources(self, error_threshold: float = 0.1) -> List[str]:
        """识别有问题的令牌源"""
        problematic = []
        
        for source, count in self.metrics["token_source_stats"].items():
            if count > 0:
                total = sum(self.metrics["token_source_stats"].values())
                error_rate = self.metrics["error_count"] / self.metrics["validation_count"]
                
                if error_rate > error_threshold:
                    problematic.append(source)
        
        return problematic
```

### 2. 用户活动分析

```python
class UserActivityAnalyzer:
    def __init__(self):
        self.user_activities: Dict[str, Dict[str, Any]] = {}
    
    def track_user_activity(self, user_id: str, action: str, metadata: Dict[str, Any] = None):
        """跟踪用户活动"""
        if user_id not in self.user_activities:
            self.user_activities[user_id] = {
                "first_seen": time.time(),
                "last_seen": time.time(),
                "actions": [],
                "metadata": {}
            }
        
        activity = self.user_activities[user_id]
        activity["last_seen"] = time.time()
        activity["actions"].append({
            "action": action,
            "timestamp": time.time(),
            "metadata": metadata or {}
        })
    
    def get_user_activity_summary(self, user_id: str, days: int = 7) -> Dict[str, Any]:
        """获取用户活动摘要"""
        if user_id not in self.user_activities:
            return {}
        
        activity = self.user_activities[user_id]
        cutoff_time = time.time() - (days * 24 * 3600)
        
        recent_actions = [
            action for action in activity["actions"]
            if action["timestamp"] > cutoff_time
        ]
        
        return {
            "user_id": user_id,
            "first_seen": activity["first_seen"],
            "last_seen": activity["last_seen"],
            "recent_actions_count": len(recent_actions),
            "days_active": days,
            "action_types": list(set(action["action"] for action in recent_actions))
        }
    
    def get_inactive_users(self, days: int = 30) -> List[str]:
        """获取不活跃用户"""
        cutoff_time = time.time() - (days * 24 * 3600)
        
        inactive_users = []
        for user_id, activity in self.user_activities.items():
            if activity["last_seen"] < cutoff_time:
                inactive_users.append(user_id)
        
        return inactive_users
```

## 最佳实践

### 1. 令牌安全

- **密钥管理**: 使用强密钥并定期轮换
- **令牌过期**: 设置合理的过期时间
- **HTTPS 传输**: 始终使用 HTTPS 传输令牌
- **最小权限**: 令牌只包含必要的声明

### 2. 性能优化

- **令牌缓存**: 缓存验证结果以减少计算开销
- **批量验证**: 支持批量令牌验证
- **异步验证**: 使用异步验证避免阻塞
- **监控指标**: 监控验证性能指标

### 3. 错误处理

- **详细错误日志**: 记录详细的错误信息
- **用户友好**: 提供清晰的错误消息
- **优雅降级**: 在认证失败时提供备用方案
- **错误分类**: 区分不同类型的认证错误

### 4. 会话管理

- **会话超时**: 设置合理的会话超时时间
- **会话清理**: 定期清理过期会话
- **会话持久化**: 考虑将会话数据持久化存储
- **会话恢复**: 支持会话恢复机制

## 故障排除

### 常见问题

#### 令牌验证失败

**问题**: JWT 令牌验证失败
**解决方案**:
1. 检查密钥配置
2. 验证令牌格式
3. 确认时钟同步
4. 检查令牌是否过期

#### 权限验证失败

**问题**: RBAC 权限验证失败
**解决方案**:
1. 检查用户角色和权限配置
2. 验证权限范围定义
3. 检查端点权限要求
4. 确认权限映射关系

#### 会话管理问题

**问题**: 会话无法正确创建或管理
**解决方案**:
1. 检查会话配置
2. 验证会话 ID 生成逻辑
3. 检查会话存储机制
4. 确认会话清理逻辑

## 下一步

- 查看[自定义中间件](/agent-os/middleware/custom)
- 了解[安全功能](/agent-os/security)
- 查看[AgentOS 配置](/agent-os/config)
- 查看[AgentOS API](/agent-os/api)