---
title: å–æ¶ˆæ™ºèƒ½ä½“è¿è¡Œ
---

æ­¤ç¤ºä¾‹æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹å–æ¶ˆæ­£åœ¨è¿è¡Œçš„æ™ºèƒ½ä½“æ‰§è¡Œï¼Œå±•ç¤ºå¦‚ä½•å¯åŠ¨ä¸€ä¸ªé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡å¹¶ä»å¦ä¸€ä¸ªçº¿ç¨‹å–æ¶ˆå®ƒã€‚

<Steps>

  <Step title="åˆ›å»º Python æ–‡ä»¶">
    ```bash
    touch cancel_a_run.py
    ```
  </Step>


  <Step title="å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ°æ‚¨çš„ Python æ–‡ä»¶ä¸­">
    ```python cancel_a_run.py
    """
    æ¼”ç¤ºå¦‚ä½•å–æ¶ˆæ­£åœ¨è¿è¡Œçš„æ™ºèƒ½ä½“æ‰§è¡Œçš„ç¤ºä¾‹ã€‚

    æ­¤ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ï¼š
    1. åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­å¯åŠ¨æ™ºèƒ½ä½“è¿è¡Œ
    2. ä»å¦ä¸€ä¸ªçº¿ç¨‹å–æ¶ˆè¿è¡Œ
    3. å¤„ç†å·²å–æ¶ˆçš„å“åº”
    """

    import threading
    import time

    from agno.agent import Agent
    from agno.models.openai import OpenAIChat
    from agno.run.agent import RunEvent
    from agno.run.base import RunStatus


    def long_running_task(agent: Agent, run_id_container: dict):
        """
        æ¨¡æ‹Ÿä¸€ä¸ªå¯ä»¥è¢«å–æ¶ˆçš„é•¿æ—¶é—´è¿è¡Œçš„æ™ºèƒ½ä½“ä»»åŠ¡ã€‚

        å‚æ•°ï¼š
            agent: è¦è¿è¡Œçš„æ™ºèƒ½ä½“
            run_id_container: ç”¨äºå­˜å‚¨run_idä»¥è¿›è¡Œå–æ¶ˆæ“ä½œçš„å­—å…¸

        è¿”å›ï¼š
            åŒ…å«è¿è¡Œç»“æœå’ŒçŠ¶æ€çš„å­—å…¸
        """
        try:
            # å¯åŠ¨æ™ºèƒ½ä½“è¿è¡Œ - è¿™æ¨¡æ‹Ÿäº†ä¸€ä¸ªé•¿æ—¶é—´ä»»åŠ¡
            final_response = None
            content_pieces = []

            for chunk in agent.run(
                "å†™ä¸€ä¸ªå…³äºé¾™å­¦ä¹ ç¼–ç¨‹çš„å¾ˆé•¿çš„æ•…äº‹ã€‚"
                "è‡³å°‘2000å­—ï¼ŒåŒ…å«è¯¦ç»†çš„æè¿°å’Œå¯¹è¯ã€‚"
                "æ…¢æ…¢æ¥ï¼Œè¦éå¸¸è¯¦å°½ã€‚",
                stream=True,
            ):
                if "run_id" not in run_id_container and chunk.run_id:
                    run_id_container["run_id"] = chunk.run_id

                if chunk.event == RunEvent.run_content:
                    print(chunk.content, end="", flush=True)
                    content_pieces.append(chunk.content)
                # When the run is cancelled, a `RunEvent.run_cancelled` event is emitted
                elif chunk.event == RunEvent.run_cancelled:
                    print(f"\nğŸš« Run was cancelled: {chunk.run_id}")
                    run_id_container["result"] = {
                        "status": "cancelled",
                        "run_id": chunk.run_id,
                        "cancelled": True,
                        "content": "".join(content_pieces)[:200] + "..."
                        if content_pieces
                        else "No content before cancellation",
                    }
                    return
                elif hasattr(chunk, "status") and chunk.status == RunStatus.completed:
                    final_response = chunk

            # If we get here, the run completed successfully
            if final_response:
                run_id_container["result"] = {
                    "status": final_response.status.value
                    if final_response.status
                    else "completed",
                    "run_id": final_response.run_id,
                    "cancelled": final_response.status == RunStatus.cancelled,
                    "content": ("".join(content_pieces)[:200] + "...")
                    if content_pieces
                    else "No content",
                }
            else:
                run_id_container["result"] = {
                    "status": "unknown",
                    "run_id": run_id_container.get("run_id"),
                    "cancelled": False,
                    "content": ("".join(content_pieces)[:200] + "...")
                    if content_pieces
                    else "No content",
                }

        except Exception as e:
            print(f"\nâŒ Exception in run: {str(e)}")
            run_id_container["result"] = {
                "status": "error",
                "error": str(e),
                "run_id": run_id_container.get("run_id"),
                "cancelled": True,
                "content": "Error occurred",
            }


    def cancel_after_delay(agent: Agent, run_id_container: dict, delay_seconds: int = 3):
        """
        åœ¨æŒ‡å®šå»¶è¿Ÿåå–æ¶ˆæ™ºèƒ½ä½“è¿è¡Œã€‚

        å‚æ•°ï¼š
            agent: åº”è¯¥è¢«å–æ¶ˆè¿è¡Œçš„æ™ºèƒ½ä½“
            run_id_container: åŒ…å«è¦å–æ¶ˆçš„run_idçš„å­—å…¸
            delay_seconds: å–æ¶ˆå‰ç­‰å¾…çš„æ—¶é—´ï¼ˆç§’ï¼‰
        """
        print(f"â° å°†åœ¨ {delay_seconds} ç§’åå–æ¶ˆè¿è¡Œ...")
        time.sleep(delay_seconds)

        run_id = run_id_container.get("run_id")
        if run_id:
            print(f"ğŸš« æ­£åœ¨å–æ¶ˆè¿è¡Œï¼š{run_id}")
            success = agent.cancel_run(run_id)
            if success:
                print(f"âœ… è¿è¡Œ {run_id} å·²æ ‡è®°ä¸ºå–æ¶ˆ")
            else:
                print(
                    f"âŒ å–æ¶ˆè¿è¡Œ {run_id} å¤±è´¥ï¼ˆå¯èƒ½ä¸å­˜åœ¨æˆ–å·²å®Œæˆï¼‰"
                )
        else:
            print("âš ï¸  æœªæ‰¾åˆ°è¦å–æ¶ˆçš„ run_id")


    def main():
        """æ¼”ç¤ºè¿è¡Œå–æ¶ˆçš„ä¸»å‡½æ•°ã€‚"""

        # ä½¿ç”¨æ¨¡å‹åˆå§‹åŒ–æ™ºèƒ½ä½“
        agent = Agent(
            name="StorytellerAgent",
            model=OpenAIChat(id="gpt-5-mini"),  # ä½¿ç”¨èƒ½å¤Ÿç”Ÿæˆé•¿å“åº”çš„æ¨¡å‹
            description="ä¸€ä¸ªç¼–å†™è¯¦ç»†æ•…äº‹çš„æ™ºèƒ½ä½“",
        )

        print("ğŸš€ å¼€å§‹æ™ºèƒ½ä½“è¿è¡Œå–æ¶ˆç¤ºä¾‹...")
        print("=" * 50)

        # ç”¨äºåœ¨çº¿ç¨‹é—´å…±äº«run_idçš„å®¹å™¨
        run_id_container = {}

        # åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­å¯åŠ¨æ™ºèƒ½ä½“è¿è¡Œ
        agent_thread = threading.Thread(
            target=lambda: long_running_task(agent, run_id_container), name="AgentRunThread"
        )

        # å¯åŠ¨å–æ¶ˆçº¿ç¨‹
        cancel_thread = threading.Thread(
            target=cancel_after_delay,
            args=(agent, run_id_container, 8),  # 8ç§’åå–æ¶ˆ
            name="CancelThread",
        )

        # å¯åŠ¨ä¸¤ä¸ªçº¿ç¨‹
        print("ğŸƒ å¯åŠ¨æ™ºèƒ½ä½“è¿è¡Œçº¿ç¨‹...")
        agent_thread.start()

        print("ğŸƒ å¯åŠ¨å–æ¶ˆçº¿ç¨‹...")
        cancel_thread.start()

        # ç­‰å¾…ä¸¤ä¸ªçº¿ç¨‹å®Œæˆ
        print("âŒ› ç­‰å¾…çº¿ç¨‹å®Œæˆ...")
        agent_thread.join()
        cancel_thread.join()

        # æ‰“å°ç»“æœ
        print("\n" + "=" * 50)
        print("ğŸ“Š ç»“æœï¼š")
        print("=" * 50)

        result = run_id_container.get("result")
        if result:
            print(f"çŠ¶æ€: {result['status']}")
            print(f"è¿è¡ŒID: {result['run_id']}")
            print(f"æ˜¯å¦å·²å–æ¶ˆ: {result['cancelled']}")

            if result.get("error"):
                print(f"é”™è¯¯: {result['error']}")
            else:
                print(f"å†…å®¹é¢„è§ˆ: {result['content']}")

            if result["cancelled"]:
                print("\nâœ… æˆåŠŸï¼šè¿è¡Œå·²æˆåŠŸå–æ¶ˆï¼")
            else:
                print("\nâš ï¸  è­¦å‘Šï¼šè¿è¡Œåœ¨å–æ¶ˆå‰å·²å®Œæˆ")
        else:
            print("âŒ æœªè·å¾—ç»“æœ - æ£€æŸ¥å–æ¶ˆæ˜¯å¦åœ¨æµå¼ä¼ è¾“æœŸé—´å‘ç”Ÿ")

        print("\nğŸ ç¤ºä¾‹å®Œæˆï¼")


    if __name__ == "__main__":
        # è¿è¡Œä¸»ç¤ºä¾‹
        main()
    ```
  </Step>

  <Snippet file="create-venv-step.mdx" />

  <Step title="å®‰è£…åº“">
    ```bash
    pip install -U agno openai
    ```
  </Step>

  <Step title="å¯¼å‡ºæ‚¨çš„ OpenAI API å¯†é’¥">

    <CodeGroup>

    ```bash Mac/Linux
      export OPENAI_API_KEY="your_openai_api_key_here"
    ```

    ```bash Windows
      $Env:OPENAI_API_KEY="your_openai_api_key_here"
    ```
    </CodeGroup>
  </Step>

  <Step title="è¿è¡Œæ™ºèƒ½ä½“">
    <CodeGroup>
    ```bash Mac
    python cancel_a_run.py
    ```

    ```bash Windows
    python cancel_a_run.py
    ```
    </CodeGroup>
  </Step>

</Steps>
